using System.Reflection;
using System.Text;
using System.Text.RegularExpressions;
using HraBot.Core.Common;

namespace HraBot.CodeGen.Serverless;

public class WebApplicationEndpointBuilder
{
    public static async Task Build()
    {
        var repoRoot = FindRepoRoot(Directory.GetCurrentDirectory());
        if (repoRoot is null)
        {
            throw new InvalidOperationException(
                "Could not locate repo root (expected HraBot.slnx)."
            );
        }

        var outputDir = Path.Combine(repoRoot, "src", "HraBot.Core", "Generated");
        Directory.CreateDirectory(outputDir);

        var coreAssembly = typeof(BaseEndpoint<,>).Assembly;
        var endpointTypes = coreAssembly
            .GetTypes()
            .Where(type => type.IsClass && !type.IsAbstract)
            .Select(type => (Type: type, Attribute: GetEndpointAttribute(type)))
            .Where(item => item.Attribute is not null)
            .ToList();

        foreach (var (type, attribute) in endpointTypes)
        {
            var http = attribute!.ConstructorArguments.ElementAtOrDefault(0).Value as string;
            var route = attribute.ConstructorArguments.ElementAtOrDefault(1).Value as string;

            if (string.IsNullOrWhiteSpace(http) || string.IsNullOrWhiteSpace(route))
            {
                continue;
            }

            var requestType = GetEndpointRequestType(type);
            if (requestType is null)
            {
                continue;
            }

            var classNamespace = type.Namespace ?? "Generated";
            var className = type.Name;
            var requestTypeName = GetTypeName(requestType);
            var (_, routeParameters) = ParseRouteTemplate(route);

            var fileContents = BuildWebApplicationPartial(
                classNamespace,
                className,
                requestTypeName,
                requestType,
                http,
                route,
                routeParameters
            );
            var outputPath = Path.Combine(outputDir, $"{className}.WebApp.g.cs");
            await File.WriteAllTextAsync(outputPath, fileContents, Encoding.ASCII);
        }
    }

    static CustomAttributeData? GetEndpointAttribute(Type type)
    {
        foreach (var attribute in type.CustomAttributes)
        {
            var name = attribute.AttributeType.Name;
            if (
                name.Equals("HraBotEndpointAttribute", StringComparison.OrdinalIgnoreCase)
                || name.Equals("HraBotEndpoint", StringComparison.OrdinalIgnoreCase)
            )
            {
                return attribute;
            }
        }

        return null;
    }

    static Type? GetEndpointRequestType(Type type)
    {
        var current = type;
        while (current is not null)
        {
            if (current.IsGenericType)
            {
                var definition = current.GetGenericTypeDefinition();
                if (definition == typeof(BaseEndpoint<,>))
                {
                    return current.GetGenericArguments()[0];
                }
            }

            current = current.BaseType;
        }

        return null;
    }

    static string BuildWebApplicationPartial(
        string classNamespace,
        string className,
        string requestTypeName,
        Type requestType,
        string http,
        string route,
        IReadOnlyList<RouteParameter> routeParameters
    )
    {
        var builder = new StringBuilder();
        builder.AppendLine("// <auto-generated />");
        builder.AppendLine("using Microsoft.AspNetCore.Builder;");
        builder.AppendLine("using Microsoft.AspNetCore.Mvc;");
        builder.AppendLine("using Microsoft.AspNetCore.Routing;");
        builder.AppendLine();
        builder.AppendLine($"namespace {classNamespace};");
        builder.AppendLine();
        builder.AppendLine(
            $"public class {className}_ConfigureWebApi : HraBot.Core.Common.IBaseEndpoint"
        );
        builder.AppendLine("{");
        builder.AppendLine("    public static void Configure(IEndpointRouteBuilder builder)");
        builder.AppendLine("    {");

        var includeBody = !string.Equals(http, "get", StringComparison.OrdinalIgnoreCase);
        var signature = BuildHandlerSignature(
            className,
            requestTypeName,
            routeParameters,
            includeBody
        );
        var (requestConstruction, executeArgument) = BuildRequestInvocation(
            requestTypeName,
            requestType,
            routeParameters,
            includeBody
        );

        var mapMethod = GetMapMethod(http);
        var mapTarget = mapMethod.UseMapMethods
            ? $"MapMethods(\"{route}\", new[] {{ \"{mapMethod.Verb}\" }}, "
            : $"{mapMethod.MethodName}(\"{route}\", ";

        builder.AppendLine($"        builder.{mapTarget}async ({signature}) =>");
        builder.AppendLine("        {");
        if (!string.IsNullOrWhiteSpace(requestConstruction))
        {
            builder.AppendLine($"            {requestConstruction}");
        }
        builder.AppendLine(
            @$"
#if GENERATING_OPENAPI
            return await endpoint.ReturnResponse();
#else
            return (await endpoint.ExecuteAsync({executeArgument})).ToWebResult();
#endif
            "
        );
        builder.AppendLine("        });");

        builder.AppendLine("    }");
        builder.AppendLine("}");
        return builder.ToString();
    }

    static string? FindRepoRoot(string startPath)
    {
        var current = new DirectoryInfo(startPath);
        while (current is not null)
        {
            var slnxPath = Path.Combine(current.FullName, "HraBot.slnx");
            if (File.Exists(slnxPath))
            {
                return current.FullName;
            }

            current = current.Parent;
        }

        return null;
    }

    static string GetTypeName(Type type)
    {
        if (type.IsArray)
        {
            var elementType = type.GetElementType();
            return $"{GetTypeName(elementType!)}[]";
        }

        if (TypeNameAliases.TryGetValue(type, out var alias))
        {
            return alias;
        }

        if (type.IsGenericType)
        {
            var genericName = type.Name;
            var tickIndex = genericName.IndexOf('`');
            if (tickIndex >= 0)
            {
                genericName = genericName[..tickIndex];
            }

            var namespacePrefix = string.IsNullOrEmpty(type.Namespace) ? "" : type.Namespace + ".";
            var typeName = $"{namespacePrefix}{genericName}";
            var arguments = type.GetGenericArguments().Select(GetTypeName);
            return $"{typeName}<{string.Join(", ", arguments)}>";
        }

        var fullName = type.FullName ?? type.Name;
        return fullName.Replace("+", ".");
    }

    static Dictionary<Type, string> TypeNameAliases = new()
    {
        [typeof(bool)] = "bool",
        [typeof(byte)] = "byte",
        [typeof(sbyte)] = "sbyte",
        [typeof(char)] = "char",
        [typeof(decimal)] = "decimal",
        [typeof(double)] = "double",
        [typeof(float)] = "float",
        [typeof(int)] = "int",
        [typeof(uint)] = "uint",
        [typeof(long)] = "long",
        [typeof(ulong)] = "ulong",
        [typeof(object)] = "object",
        [typeof(short)] = "short",
        [typeof(ushort)] = "ushort",
        [typeof(string)] = "string",
        [typeof(void)] = "void",
    };

    static (string SanitizedRoute, List<RouteParameter> Parameters) ParseRouteTemplate(string route)
    {
        var parameters = new List<RouteParameter>();
        var sanitizedRoute = RouteParameterRegex.Replace(
            route,
            match =>
            {
                var raw = match.Groups[1].Value;
                var parts = raw.Split(':', StringSplitOptions.RemoveEmptyEntries);
                if (parts.Length == 0)
                {
                    return match.Value;
                }

                var name = parts[0];
                var constraint = parts.Length > 1 ? parts[1] : null;
                var typeToken = ExtractTypeToken(constraint);
                var parameterType = GetRouteParameterType(typeToken);
                parameters.Add(new RouteParameter(name, parameterType, typeToken ?? "string"));

                return "{" + name + "}";
            }
        );

        return (sanitizedRoute, parameters);
    }

    static string? ExtractTypeToken(string? constraint)
    {
        if (string.IsNullOrWhiteSpace(constraint))
        {
            return null;
        }

        var parenIndex = constraint.IndexOf('(');
        if (parenIndex >= 0)
        {
            return constraint[..parenIndex];
        }

        return constraint;
    }

    static Type GetRouteParameterType(string? typeToken)
    {
        if (string.IsNullOrWhiteSpace(typeToken))
        {
            return typeof(string);
        }

        if (RouteTypeMap.TryGetValue(typeToken, out var mappedType))
        {
            return mappedType;
        }

        return typeof(string);
    }

    static string BuildHandlerSignature(
        string className,
        string requestTypeName,
        IReadOnlyList<RouteParameter> routeParameters,
        bool includeBody
    )
    {
        if (routeParameters.Count == 0)
        {
            if (!includeBody)
            {
                return $"[FromServices] {className} endpoint";
            }

            return $"[FromServices] {className} endpoint, [FromBody] {requestTypeName} request";
        }

        var signatureParts = new List<string> { $"[FromServices] {className} endpoint" };
        foreach (var parameter in routeParameters)
        {
            signatureParts.Add(
                $"{GetTypeName(parameter.ParameterType)} {EscapeIdentifier(parameter.Name)}"
            );
        }

        return string.Join(", ", signatureParts);
    }

    static (string RequestConstruction, string ExecuteArgument) BuildRequestInvocation(
        string requestTypeName,
        Type requestType,
        IReadOnlyList<RouteParameter> routeParameters,
        bool includeBody
    )
    {
        if (routeParameters.Count == 0)
        {
            if (!includeBody)
            {
                return (string.Empty, "default!");
            }

            return (string.Empty, "request");
        }

        if (routeParameters.Count == 1)
        {
            var parameter = routeParameters[0];
            if (IsCompatibleRequestType(requestType, parameter.ParameterType))
            {
                return (string.Empty, EscapeIdentifier(parameter.Name));
            }
        }

        var requestExpression = BuildRequestExpression(
            requestTypeName,
            requestType,
            routeParameters
        );
        return ($"var request = {requestExpression};", "request");
    }

    static string BuildRequestExpression(
        string requestTypeName,
        Type requestType,
        IReadOnlyList<RouteParameter> routeParameters
    )
    {
        var constructor = FindMatchingConstructor(requestType, routeParameters);
        if (constructor is not null)
        {
            var constructorArgs = constructor
                .GetParameters()
                .Select(param =>
                    EscapeIdentifier(
                        routeParameters
                            .First(p =>
                                p.Name.Equals(param.Name, StringComparison.OrdinalIgnoreCase)
                            )
                            .Name
                    )
                );
            return $"new {requestTypeName}({string.Join(", ", constructorArgs)})";
        }

        var properties = FindMatchingProperties(requestType, routeParameters);
        if (properties is not null)
        {
            var assignments = properties.Select(prop =>
                $"{prop.Property.Name} = {EscapeIdentifier(prop.Parameter.Name)}"
            );
            return $"new {requestTypeName} {{ {string.Join(", ", assignments)} }}";
        }

        return $"new {requestTypeName}()";
    }

    static ConstructorInfo? FindMatchingConstructor(
        Type requestType,
        IReadOnlyList<RouteParameter> routeParameters
    )
    {
        foreach (var constructor in requestType.GetConstructors())
        {
            var parameters = constructor.GetParameters();
            if (parameters.Length != routeParameters.Count)
            {
                continue;
            }

            if (
                parameters.All(param =>
                    routeParameters.Any(routeParam =>
                        routeParam.Name.Equals(param.Name, StringComparison.OrdinalIgnoreCase)
                    )
                )
            )
            {
                return constructor;
            }
        }

        return null;
    }

    static List<(PropertyInfo Property, RouteParameter Parameter)>? FindMatchingProperties(
        Type requestType,
        IReadOnlyList<RouteParameter> routeParameters
    )
    {
        var properties = requestType
            .GetProperties(BindingFlags.Public | BindingFlags.Instance)
            .Where(prop => prop.SetMethod is not null)
            .ToList();

        var matches = new List<(PropertyInfo Property, RouteParameter Parameter)>();
        foreach (var routeParameter in routeParameters)
        {
            var property = properties.FirstOrDefault(prop =>
                prop.Name.Equals(routeParameter.Name, StringComparison.OrdinalIgnoreCase)
            );
            if (property is null)
            {
                return null;
            }

            matches.Add((property, routeParameter));
        }

        return matches;
    }

    static string EscapeIdentifier(string identifier) =>
        CSharpKeywords.Contains(identifier) ? "@" + identifier : identifier;

    static bool IsCompatibleRequestType(Type requestType, Type parameterType)
    {
        if (requestType == parameterType)
        {
            return true;
        }

        if (
            requestType.IsGenericType
            && requestType.GetGenericTypeDefinition() == typeof(Nullable<>)
        )
        {
            var underlying = Nullable.GetUnderlyingType(requestType);
            return underlying == parameterType;
        }

        return false;
    }

    static (string MethodName, bool UseMapMethods, string Verb) GetMapMethod(string http)
    {
        if (string.IsNullOrWhiteSpace(http))
        {
            return ("MapMethods", true, "GET");
        }

        return http.Trim().ToLowerInvariant() switch
        {
            "get" => ("MapGet", false, "GET"),
            "post" => ("MapPost", false, "POST"),
            "put" => ("MapPut", false, "PUT"),
            "patch" => ("MapPatch", false, "PATCH"),
            "delete" => ("MapDelete", false, "DELETE"),
            _ => ("MapMethods", true, http.Trim().ToUpperInvariant()),
        };
    }

    record RouteParameter(string Name, Type ParameterType, string TypeToken);

    static readonly Regex RouteParameterRegex = new(@"\{([^{}]+)\}");

    static readonly Dictionary<string, Type> RouteTypeMap = new(StringComparer.OrdinalIgnoreCase)
    {
        ["int"] = typeof(int),
        ["long"] = typeof(long),
        ["short"] = typeof(short),
        ["bool"] = typeof(bool),
        ["guid"] = typeof(Guid),
        ["datetime"] = typeof(DateTime),
        ["decimal"] = typeof(decimal),
        ["double"] = typeof(double),
        ["float"] = typeof(float),
        ["string"] = typeof(string),
    };

    static readonly HashSet<string> CSharpKeywords = new(StringComparer.Ordinal)
    {
        "abstract",
        "as",
        "base",
        "bool",
        "break",
        "byte",
        "case",
        "catch",
        "char",
        "checked",
        "class",
        "const",
        "continue",
        "decimal",
        "default",
        "delegate",
        "do",
        "double",
        "else",
        "enum",
        "event",
        "explicit",
        "extern",
        "false",
        "finally",
        "fixed",
        "float",
        "for",
        "foreach",
        "goto",
        "if",
        "implicit",
        "in",
        "int",
        "interface",
        "internal",
        "is",
        "lock",
        "long",
        "namespace",
        "new",
        "null",
        "object",
        "operator",
        "out",
        "override",
        "params",
        "private",
        "protected",
        "public",
        "readonly",
        "ref",
        "return",
        "sbyte",
        "sealed",
        "short",
        "sizeof",
        "stackalloc",
        "static",
        "string",
        "struct",
        "switch",
        "this",
        "throw",
        "true",
        "try",
        "typeof",
        "uint",
        "ulong",
        "unchecked",
        "unsafe",
        "ushort",
        "using",
        "virtual",
        "void",
        "volatile",
        "while",
    };
}
