// <auto-generated />
using System;
using System.Collections.Generic;
using System.Reflection;
using Microsoft.EntityFrameworkCore;
using Microsoft.EntityFrameworkCore.ChangeTracking;
using Microsoft.EntityFrameworkCore.ChangeTracking.Internal;
using Microsoft.EntityFrameworkCore.Infrastructure;
using Microsoft.EntityFrameworkCore.Metadata;
using Microsoft.EntityFrameworkCore.Metadata.Internal;
using Microsoft.EntityFrameworkCore.Storage;
using Microsoft.EntityFrameworkCore.Storage.Json;
using Microsoft.EntityFrameworkCore.Storage.ValueConversion;
using Npgsql.EntityFrameworkCore.PostgreSQL.Metadata;
using Npgsql.EntityFrameworkCore.PostgreSQL.Storage.Internal.Mapping;

#pragma warning disable 219, 612, 618
#nullable disable

namespace HraBot.Core.Generated
{
    [EntityFrameworkInternal]
    public partial class MessageEntityType
    {
        public static RuntimeEntityType Create(RuntimeModel model, RuntimeEntityType baseEntityType = null)
        {
            var runtimeEntityType = model.AddEntityType(
                "HraBot.Core.Message",
                typeof(Message),
                baseEntityType,
                propertyCount: 6,
                navigationCount: 1,
                foreignKeyCount: 1,
                unnamedIndexCount: 1,
                keyCount: 1);

            var id = runtimeEntityType.AddProperty(
                "Id",
                typeof(long),
                propertyInfo: typeof(Message).GetProperty("Id", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Message).GetField("<Id>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                valueGenerated: ValueGenerated.OnAdd,
                afterSaveBehavior: PropertySaveBehavior.Throw,
                sentinel: 0L);
            id.SetGetter(
                long (Message instance) => MessageUnsafeAccessors.Id(instance),
                bool (Message instance) => MessageUnsafeAccessors.Id(instance) == 0L);
            id.SetSetter(
                Message (Message instance, long value) =>
                {
                    MessageUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetMaterializationSetter(
                Message (Message instance, long value) =>
                {
                    MessageUnsafeAccessors.Id(instance) = value;
                    return instance;
                });
            id.SetAccessors(
                long (IInternalEntry entry) => (entry.FlaggedAsStoreGenerated(0) ? entry.ReadStoreGeneratedValue<long>(0) : (entry.FlaggedAsTemporary(0) && MessageUnsafeAccessors.Id(((Message)(entry.Entity))) == 0L ? entry.ReadTemporaryValue<long>(0) : MessageUnsafeAccessors.Id(((Message)(entry.Entity))))),
                long (IInternalEntry entry) => MessageUnsafeAccessors.Id(((Message)(entry.Entity))),
                long (IInternalEntry entry) => entry.ReadOriginalValue<long>(id, 0),
                long (IInternalEntry entry) => ((InternalEntityEntry)(entry)).ReadRelationshipSnapshotValue<long>(id, 0));
            id.SetPropertyIndexes(
                index: 0,
                originalValueIndex: 0,
                shadowIndex: -1,
                relationshipIndex: 0,
                storeGenerationIndex: 0);
            id.TypeMapping = LongTypeMapping.Default.Clone(
                comparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                keyComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v),
                providerValueComparer: new ValueComparer<long>(
                    bool (long v1, long v2) => v1 == v2,
                    int (long v) => ((object)v).GetHashCode(),
                    long (long v) => v));
            id.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(id));
            id.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.IdentityByDefaultColumn);

            var aiModel = runtimeEntityType.AddProperty(
                "AiModel",
                typeof(AiModel?),
                propertyInfo: typeof(Message).GetProperty("AiModel", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Message).GetField("<AiModel>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                nullable: true);
            aiModel.SetGetter(
                AiModel? (Message instance) => MessageUnsafeAccessors.AiModel(instance),
                bool (Message instance) => !(MessageUnsafeAccessors.AiModel(instance).HasValue));
            aiModel.SetSetter(
                Message (Message instance, AiModel? value) =>
                {
                    MessageUnsafeAccessors.AiModel(instance) = (value == null ? value : ((AiModel? )(((AiModel)(value)))));
                    return instance;
                });
            aiModel.SetMaterializationSetter(
                Message (Message instance, AiModel? value) =>
                {
                    MessageUnsafeAccessors.AiModel(instance) = (value == null ? value : ((AiModel? )(((AiModel)(value)))));
                    return instance;
                });
            aiModel.SetAccessors(
                AiModel? (IInternalEntry entry) => MessageUnsafeAccessors.AiModel(((Message)(entry.Entity))),
                AiModel? (IInternalEntry entry) => MessageUnsafeAccessors.AiModel(((Message)(entry.Entity))),
                AiModel? (IInternalEntry entry) => entry.ReadOriginalValue<AiModel?>(aiModel, 1),
                AiModel? (IInternalEntry entry) => entry.GetCurrentValue<AiModel?>(aiModel));
            aiModel.SetPropertyIndexes(
                index: 1,
                originalValueIndex: 1,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            aiModel.TypeMapping = ByteTypeMapping.Default.Clone(
                comparer: new ValueComparer<AiModel>(
                    bool (AiModel v1, AiModel v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (AiModel v) => ((object)v).GetHashCode(),
                    AiModel (AiModel v) => v),
                keyComparer: new ValueComparer<AiModel>(
                    bool (AiModel v1, AiModel v2) => object.Equals(((object)(v1)), ((object)(v2))),
                    int (AiModel v) => ((object)v).GetHashCode(),
                    AiModel (AiModel v) => v),
                providerValueComparer: new ValueComparer<byte>(
                    bool (byte v1, byte v2) => v1 == v2,
                    int (byte v) => ((int)(v)),
                    byte (byte v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "smallint"),
                converter: new ValueConverter<AiModel, byte>(
                    byte (AiModel value) => ((byte)(value)),
                    AiModel (byte value) => ((AiModel)(value))),
                jsonValueReaderWriter: new JsonConvertedValueReaderWriter<AiModel, byte>(
                    JsonByteReaderWriter.Instance,
                    new ValueConverter<AiModel, byte>(
                        byte (AiModel value) => ((byte)(value)),
                        AiModel (byte value) => ((AiModel)(value)))));
            aiModel.SetComparer(new NullableValueComparer<AiModel>(aiModel.TypeMapping.Comparer));
            aiModel.SetKeyComparer(new NullableValueComparer<AiModel>(aiModel.TypeMapping.KeyComparer));
            aiModel.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

            var content = runtimeEntityType.AddProperty(
                "Content",
                typeof(string),
                propertyInfo: typeof(Message).GetProperty("Content", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                fieldInfo: typeof(Message).GetField("<Content>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
                maxLength: 2000);
            content.SetGetter(
                string (Message instance) => MessageUnsafeAccessors.Content(instance),
                bool (Message instance) => MessageUnsafeAccessors.Content(instance) == null);
            content.SetSetter(
                Message (Message instance, string value) =>
                {
                    MessageUnsafeAccessors.Content(instance) = value;
                    return instance;
                });
            content.SetMaterializationSetter(
                Message (Message instance, string value) =>
                {
                    MessageUnsafeAccessors.Content(instance) = value;
                    return instance;
                });
            content.SetAccessors(
                string (IInternalEntry entry) => MessageUnsafeAccessors.Content(((Message)(entry.Entity))),
                string (IInternalEntry entry) => MessageUnsafeAccessors.Content(((Message)(entry.Entity))),
                string (IInternalEntry entry) => entry.ReadOriginalValue<string>(content, 2),
                string (IInternalEntry entry) => entry.GetCurrentValue<string>(content));
            content.SetPropertyIndexes(
                index: 2,
                originalValueIndex: 2,
                shadowIndex: -1,
                relationshipIndex: -1,
                storeGenerationIndex: -1);
            content.TypeMapping = NpgsqlStringTypeMapping.Default.Clone(
                comparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                keyComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                providerValueComparer: new ValueComparer<string>(
                    bool (string v1, string v2) => v1 == v2,
                    int (string v) => ((object)v).GetHashCode(),
                    string (string v) => v),
                mappingInfo: new RelationalTypeMappingInfo(
                    storeTypeName: "character varying(2000)",
                    size: 2000));
            content.TypeMapping = ((NpgsqlStringTypeMapping)content.TypeMapping).Clone(npgsqlDbType: NpgsqlTypes.NpgsqlDbType.Varchar);
        content.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

        var conversationId = runtimeEntityType.AddProperty(
            "ConversationId",
            typeof(long),
            propertyInfo: typeof(Message).GetProperty("ConversationId", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
            fieldInfo: typeof(Message).GetField("<ConversationId>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
            sentinel: 0L);
        conversationId.SetGetter(
            long (Message instance) => MessageUnsafeAccessors.ConversationId(instance),
            bool (Message instance) => MessageUnsafeAccessors.ConversationId(instance) == 0L);
        conversationId.SetSetter(
            Message (Message instance, long value) =>
            {
                MessageUnsafeAccessors.ConversationId(instance) = value;
                return instance;
            });
        conversationId.SetMaterializationSetter(
            Message (Message instance, long value) =>
            {
                MessageUnsafeAccessors.ConversationId(instance) = value;
                return instance;
            });
        conversationId.SetAccessors(
            long (IInternalEntry entry) => (entry.FlaggedAsStoreGenerated(3) ? entry.ReadStoreGeneratedValue<long>(1) : (entry.FlaggedAsTemporary(3) && MessageUnsafeAccessors.ConversationId(((Message)(entry.Entity))) == 0L ? entry.ReadTemporaryValue<long>(1) : MessageUnsafeAccessors.ConversationId(((Message)(entry.Entity))))),
            long (IInternalEntry entry) => MessageUnsafeAccessors.ConversationId(((Message)(entry.Entity))),
            long (IInternalEntry entry) => entry.ReadOriginalValue<long>(conversationId, 3),
            long (IInternalEntry entry) => ((InternalEntityEntry)(entry)).ReadRelationshipSnapshotValue<long>(conversationId, 1));
        conversationId.SetPropertyIndexes(
            index: 3,
            originalValueIndex: 3,
            shadowIndex: -1,
            relationshipIndex: 1,
            storeGenerationIndex: 1);
        conversationId.TypeMapping = LongTypeMapping.Default.Clone(
            comparer: new ValueComparer<long>(
                bool (long v1, long v2) => v1 == v2,
                int (long v) => ((object)v).GetHashCode(),
                long (long v) => v),
            keyComparer: new ValueComparer<long>(
                bool (long v1, long v2) => v1 == v2,
                int (long v) => ((object)v).GetHashCode(),
                long (long v) => v),
            providerValueComparer: new ValueComparer<long>(
                bool (long v1, long v2) => v1 == v2,
                int (long v) => ((object)v).GetHashCode(),
                long (long v) => v));
        conversationId.SetCurrentValueComparer(new EntryCurrentValueComparer<long>(conversationId));
        conversationId.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

        var role = runtimeEntityType.AddProperty(
            "Role",
            typeof(Role),
            propertyInfo: typeof(Message).GetProperty("Role", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
            fieldInfo: typeof(Message).GetField("<Role>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));
        role.SetGetter(
            Role (Message instance) => MessageUnsafeAccessors.Role(instance),
            bool (Message instance) => object.Equals(((object)(MessageUnsafeAccessors.Role(instance))), ((object)(Role.Undefined))));
        role.SetSetter(
            Message (Message instance, Role value) =>
            {
                MessageUnsafeAccessors.Role(instance) = value;
                return instance;
            });
        role.SetMaterializationSetter(
            Message (Message instance, Role value) =>
            {
                MessageUnsafeAccessors.Role(instance) = value;
                return instance;
            });
        role.SetAccessors(
            Role (IInternalEntry entry) => MessageUnsafeAccessors.Role(((Message)(entry.Entity))),
            Role (IInternalEntry entry) => MessageUnsafeAccessors.Role(((Message)(entry.Entity))),
            Role (IInternalEntry entry) => entry.ReadOriginalValue<Role>(role, 4),
            Role (IInternalEntry entry) => entry.GetCurrentValue<Role>(role));
        role.SetPropertyIndexes(
            index: 4,
            originalValueIndex: 4,
            shadowIndex: -1,
            relationshipIndex: -1,
            storeGenerationIndex: -1);
        role.TypeMapping = ByteTypeMapping.Default.Clone(
            comparer: new ValueComparer<Role>(
                bool (Role v1, Role v2) => object.Equals(((object)(v1)), ((object)(v2))),
                int (Role v) => ((object)v).GetHashCode(),
                Role (Role v) => v),
            keyComparer: new ValueComparer<Role>(
                bool (Role v1, Role v2) => object.Equals(((object)(v1)), ((object)(v2))),
                int (Role v) => ((object)v).GetHashCode(),
                Role (Role v) => v),
            providerValueComparer: new ValueComparer<byte>(
                bool (byte v1, byte v2) => v1 == v2,
                int (byte v) => ((int)(v)),
                byte (byte v) => v),
            mappingInfo: new RelationalTypeMappingInfo(
                storeTypeName: "smallint"),
            converter: new ValueConverter<Role, byte>(
                byte (Role value) => ((byte)(value)),
                Role (byte value) => ((Role)(value))),
            jsonValueReaderWriter: new JsonConvertedValueReaderWriter<Role, byte>(
                JsonByteReaderWriter.Instance,
                new ValueConverter<Role, byte>(
                    byte (Role value) => ((byte)(value)),
                    Role (byte value) => ((Role)(value)))));
        role.SetSentinelFromProviderValue((byte)0);
        role.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

        var sequence = runtimeEntityType.AddProperty(
            "Sequence",
            typeof(int),
            propertyInfo: typeof(Message).GetProperty("Sequence", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
            fieldInfo: typeof(Message).GetField("<Sequence>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly),
            sentinel: 0);
        sequence.SetGetter(
            int (Message instance) => MessageUnsafeAccessors.Sequence(instance),
            bool (Message instance) => MessageUnsafeAccessors.Sequence(instance) == 0);
        sequence.SetSetter(
            Message (Message instance, int value) =>
            {
                MessageUnsafeAccessors.Sequence(instance) = value;
                return instance;
            });
        sequence.SetMaterializationSetter(
            Message (Message instance, int value) =>
            {
                MessageUnsafeAccessors.Sequence(instance) = value;
                return instance;
            });
        sequence.SetAccessors(
            int (IInternalEntry entry) => MessageUnsafeAccessors.Sequence(((Message)(entry.Entity))),
            int (IInternalEntry entry) => MessageUnsafeAccessors.Sequence(((Message)(entry.Entity))),
            int (IInternalEntry entry) => entry.ReadOriginalValue<int>(sequence, 5),
            int (IInternalEntry entry) => entry.GetCurrentValue<int>(sequence));
        sequence.SetPropertyIndexes(
            index: 5,
            originalValueIndex: 5,
            shadowIndex: -1,
            relationshipIndex: -1,
            storeGenerationIndex: -1);
        sequence.TypeMapping = IntTypeMapping.Default.Clone(
            comparer: new ValueComparer<int>(
                bool (int v1, int v2) => v1 == v2,
                int (int v) => v,
                int (int v) => v),
            keyComparer: new ValueComparer<int>(
                bool (int v1, int v2) => v1 == v2,
                int (int v) => v,
                int (int v) => v),
            providerValueComparer: new ValueComparer<int>(
                bool (int v1, int v2) => v1 == v2,
                int (int v) => v,
                int (int v) => v),
            mappingInfo: new RelationalTypeMappingInfo(
                storeTypeName: "integer"));
        sequence.SetCurrentValueComparer(new EntryCurrentValueComparer<int>(sequence));
        sequence.AddAnnotation("Npgsql:ValueGenerationStrategy", NpgsqlValueGenerationStrategy.None);

        var key = runtimeEntityType.AddKey(
            new[] { id });
        runtimeEntityType.SetPrimaryKey(key);

        var index = runtimeEntityType.AddIndex(
            new[] { conversationId, sequence },
            unique: true);

        return runtimeEntityType;
    }

    public static RuntimeForeignKey CreateForeignKey1(RuntimeEntityType declaringEntityType, RuntimeEntityType principalEntityType)
    {
        var runtimeForeignKey = declaringEntityType.AddForeignKey(new[] { declaringEntityType.FindProperty("ConversationId") },
            principalEntityType.FindKey(new[] { principalEntityType.FindProperty("Id") }),
            principalEntityType,
            deleteBehavior: DeleteBehavior.Cascade,
            required: true);

        var conversation = declaringEntityType.AddNavigation("Conversation",
            runtimeForeignKey,
            onDependent: true,
            typeof(Conversation),
            propertyInfo: typeof(Message).GetProperty("Conversation", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
            fieldInfo: typeof(Message).GetField("<Conversation>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

        conversation.SetGetter(
            Conversation (Message instance) => MessageUnsafeAccessors.Conversation(instance),
            bool (Message instance) => MessageUnsafeAccessors.Conversation(instance) == null);
        conversation.SetSetter(
            Message (Message instance, Conversation value) =>
            {
                MessageUnsafeAccessors.Conversation(instance) = value;
                return instance;
            });
        conversation.SetMaterializationSetter(
            Message (Message instance, Conversation value) =>
            {
                MessageUnsafeAccessors.Conversation(instance) = value;
                return instance;
            });
        conversation.SetAccessors(
            Conversation (IInternalEntry entry) => MessageUnsafeAccessors.Conversation(((Message)(entry.Entity))),
            Conversation (IInternalEntry entry) => MessageUnsafeAccessors.Conversation(((Message)(entry.Entity))),
            null,
            Conversation (IInternalEntry entry) => entry.GetCurrentValue<Conversation>(conversation));
        conversation.SetPropertyIndexes(
            index: 0,
            originalValueIndex: -1,
            shadowIndex: -1,
            relationshipIndex: 2,
            storeGenerationIndex: -1);
        var messages = principalEntityType.AddNavigation("Messages",
            runtimeForeignKey,
            onDependent: false,
            typeof(List<Message>),
            propertyInfo: typeof(Conversation).GetProperty("Messages", BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly),
            fieldInfo: typeof(Conversation).GetField("<Messages>k__BackingField", BindingFlags.NonPublic | BindingFlags.Instance | BindingFlags.DeclaredOnly));

        messages.SetGetter(
            List<Message> (Conversation instance) => ConversationUnsafeAccessors.Messages(instance),
            bool (Conversation instance) => ConversationUnsafeAccessors.Messages(instance) == null);
        messages.SetSetter(
            Conversation (Conversation instance, List<Message> value) =>
            {
                ConversationUnsafeAccessors.Messages(instance) = value;
                return instance;
            });
        messages.SetMaterializationSetter(
            Conversation (Conversation instance, List<Message> value) =>
            {
                ConversationUnsafeAccessors.Messages(instance) = value;
                return instance;
            });
        messages.SetAccessors(
            List<Message> (IInternalEntry entry) => ConversationUnsafeAccessors.Messages(((Conversation)(entry.Entity))),
            List<Message> (IInternalEntry entry) => ConversationUnsafeAccessors.Messages(((Conversation)(entry.Entity))),
            null,
            List<Message> (IInternalEntry entry) => entry.GetCurrentValue<List<Message>>(messages));
        messages.SetPropertyIndexes(
            index: 0,
            originalValueIndex: -1,
            shadowIndex: -1,
            relationshipIndex: 1,
            storeGenerationIndex: -1);
        messages.SetCollectionAccessor<Conversation, List<Message>, Message>(
            List<Message> (Conversation entity) => ConversationUnsafeAccessors.Messages(entity),
            (Conversation entity, List<Message> collection) => ConversationUnsafeAccessors.Messages(entity) = ((List<Message>)(collection)),
            (Conversation entity, List<Message> collection) => ConversationUnsafeAccessors.Messages(entity) = ((List<Message>)(collection)),
            List<Message> (Conversation entity, Action<Conversation, List<Message>> setter) => ClrCollectionAccessorFactory.CreateAndSet<Conversation, List<Message>, List<Message>>(entity, setter),
            List<Message> () => new List<Message>());
        return runtimeForeignKey;
    }

    public static void CreateAnnotations(RuntimeEntityType runtimeEntityType)
    {
        var id = runtimeEntityType.FindProperty("Id");
        var aiModel = runtimeEntityType.FindProperty("AiModel");
        var content = runtimeEntityType.FindProperty("Content");
        var conversationId = runtimeEntityType.FindProperty("ConversationId");
        var role = runtimeEntityType.FindProperty("Role");
        var sequence = runtimeEntityType.FindProperty("Sequence");
        var key = runtimeEntityType.FindKey(new[] { id });
        key.SetPrincipalKeyValueFactory(KeyValueFactoryFactory.CreateSimpleNonNullableFactory<long>(key));
        key.SetIdentityMapFactory(IdentityMapFactoryFactory.CreateFactory<long>(key));
        var conversation = runtimeEntityType.FindNavigation("Conversation");
        runtimeEntityType.SetOriginalValuesFactory(
            ISnapshot (IInternalEntry source) =>
            {
                var structuralType = ((Message)(source.Entity));
                return ((ISnapshot)(new Snapshot<long, AiModel?, string, long, Role, int>(((ValueComparer<long>)(((IProperty)id).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(id)), (source.GetCurrentValue<AiModel?>(aiModel) == null ? null : ((ValueComparer<AiModel?>)(((IProperty)aiModel).GetValueComparer())).Snapshot(source.GetCurrentValue<AiModel?>(aiModel))), (source.GetCurrentValue<string>(content) == null ? null : ((ValueComparer<string>)(((IProperty)content).GetValueComparer())).Snapshot(source.GetCurrentValue<string>(content))), ((ValueComparer<long>)(((IProperty)conversationId).GetValueComparer())).Snapshot(source.GetCurrentValue<long>(conversationId)), ((ValueComparer<Role>)(((IProperty)role).GetValueComparer())).Snapshot(source.GetCurrentValue<Role>(role)), ((ValueComparer<int>)(((IProperty)sequence).GetValueComparer())).Snapshot(source.GetCurrentValue<int>(sequence)))));
            });
        runtimeEntityType.SetStoreGeneratedValuesFactory(
            ISnapshot () => ((ISnapshot)(new Snapshot<long, long>(((ValueComparer<long>)(((IProperty)id).GetValueComparer())).Snapshot(default(long)), ((ValueComparer<long>)(((IProperty)conversationId).GetValueComparer())).Snapshot(default(long))))));
        runtimeEntityType.SetTemporaryValuesFactory(
            ISnapshot (IInternalEntry source) => ((ISnapshot)(new Snapshot<long, long>(default(long), default(long)))));
        runtimeEntityType.SetShadowValuesFactory(
            ISnapshot (IDictionary<string, object> source) => Snapshot.Empty);
        runtimeEntityType.SetEmptyShadowValuesFactory(
            ISnapshot () => Snapshot.Empty);
        runtimeEntityType.SetRelationshipSnapshotFactory(
            ISnapshot (IInternalEntry source) =>
            {
                var structuralType = ((Message)(source.Entity));
                return ((ISnapshot)(new Snapshot<long, long, object>(((ValueComparer<long>)(((IProperty)id).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(id)), ((ValueComparer<long>)(((IProperty)conversationId).GetKeyValueComparer())).Snapshot(source.GetCurrentValue<long>(conversationId)), source.GetCurrentValue<Conversation>(conversation))));
            });
        runtimeEntityType.SetCounts(new PropertyCounts(
            propertyCount: 6,
            navigationCount: 1,
            complexPropertyCount: 0,
            complexCollectionCount: 0,
            originalValueCount: 6,
            shadowCount: 0,
            relationshipCount: 3,
            storeGeneratedCount: 2));
        runtimeEntityType.AddAnnotation("Relational:FunctionName", null);
        runtimeEntityType.AddAnnotation("Relational:Schema", null);
        runtimeEntityType.AddAnnotation("Relational:SqlQuery", null);
        runtimeEntityType.AddAnnotation("Relational:TableName", "Messages");
        runtimeEntityType.AddAnnotation("Relational:ViewName", null);
        runtimeEntityType.AddAnnotation("Relational:ViewSchema", null);

        Customize(runtimeEntityType);
    }

    static partial void Customize(RuntimeEntityType runtimeEntityType);
}
}
