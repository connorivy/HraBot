@page "/"
@using System.ComponentModel
@inject NavigationManager Nav
@inject IHttpClientFactory HttpClientFactory

@using System.Runtime.CompilerServices
@implements IDisposable

<PageTitle>Chat</PageTitle>

<ChatHeader OnNewChat="@ResetConversationAsync" />

<ChatMessageList Messages="@messages" InProgressMessage="@currentResponseMessage">
    <NoMessagesContent>
        <div>To get started, try asking about these example documents. You can replace these with your own data and
            replace this message.</div>
    </NoMessagesContent>
</ChatMessageList>

<div class="chat-container">
    <ChatSuggestions OnSelected="@AddUserMessageAsync" @ref="@chatSuggestions" />
    <ChatInput OnSend="@AddUserMessageAsync" @ref="@chatInput" />
</div>

@code {
    private int statefulMessageCount;
    private readonly List<ChatMessage> messages = new();
    private CancellationTokenSource? currentResponseCancellation;
    private ChatMessage? currentResponseMessage;
    private ChatInput? chatInput;
    private ChatSuggestions? chatSuggestions;
    private HttpClient? httpClient;

    protected override void OnInitialized()
    {
        httpClient = HttpClientFactory.CreateClient("HraBot.Api");
        statefulMessageCount = 0;
    }

    private async Task AddUserMessageAsync(ChatMessage userMessage)
    {
        CancelAnyCurrentResponse();

        // Add the user message to the conversation
        messages.Add(userMessage);
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();

        // Stream and display a new response from the SSE endpoint
        var responseText = new TextContent("");
        currentResponseMessage = new ChatMessage(ChatRole.Assistant, [responseText]);
        currentResponseCancellation = new();

        messages.Add(currentResponseMessage!);

        try
        {
            await foreach (var update in StreamChatResponseSse(messages.Skip(statefulMessageCount).ToList(),
            currentResponseCancellation.Token))
            {
                responseText.Text += update;
                ChatMessageItem.NotifyChanged(currentResponseMessage);
            }
        }
        catch (OperationCanceledException) { }

        // Note: ConversationId is not updated here, as SSE endpoint may not return it; adjust if needed
        statefulMessageCount = 0;
        currentResponseMessage = null;
        chatSuggestions?.Update(messages);
    }

    // Helper to POST to /api/chat/stream and consume SSE
    private async IAsyncEnumerable<string> StreamChatResponseSse(List<ChatMessage> chatMessages,
    [EnumeratorCancellation] CancellationToken cancellationToken)
    {
        var request = new ChatRequestDto
        {
            Messages = chatMessages.Select(m => new ChatRequestDto.MessageDto
            {
                Role = Map(m.Role),
                Text =
            m.Text
            }).ToList()
        };

        using var requestMessage = new HttpRequestMessage(HttpMethod.Post, "/api/chat/stream")
        {
            Content = JsonContent.Create(request)
        };
        requestMessage.Headers.Accept.Add(new System.Net.Http.Headers.MediaTypeWithQualityHeaderValue("text/event-stream"));

        using var response = await httpClient!.SendAsync(requestMessage, HttpCompletionOption.ResponseHeadersRead,
        cancellationToken);
        response.EnsureSuccessStatusCode();

        using var stream = await response.Content.ReadAsStreamAsync(cancellationToken);
        using var reader = new StreamReader(stream);
        string? line;
        while ((line = await reader.ReadLineAsync()) != null)
        {
            cancellationToken.ThrowIfCancellationRequested();
            if (line.StartsWith("data: "))
            {
                var data = line.Substring(6);
                yield return data;
            }
        }
    }

    private ChatRequestDto.ChatRole Map(Microsoft.Extensions.AI.ChatRole role)
    {
        if (role == Microsoft.Extensions.AI.ChatRole.System) return ChatRequestDto.ChatRole.System;
        if (role == Microsoft.Extensions.AI.ChatRole.User) return ChatRequestDto.ChatRole.User;
        if (role == Microsoft.Extensions.AI.ChatRole.Assistant) return ChatRequestDto.ChatRole.Assistant;
        throw new ArgumentOutOfRangeException(nameof(role), role, null);
    }
    // DTO for chat request
    private class ChatRequestDto
    {
        public List<MessageDto>? Messages { get; set; }
        public class MessageDto
        {
            public required ChatRole Role { get; set; }
            public required string Text { get; set; }
        }
        public enum ChatRole
        {
            System,
            Assistant,
            User
        }

    }

    private void CancelAnyCurrentResponse()
    {
        // If a response was cancelled while streaming, include it in the conversation so it's not lost
        if (currentResponseMessage is not null)
        {
            messages.Add(currentResponseMessage);
        }

        currentResponseCancellation?.Cancel();
        currentResponseMessage = null;
    }

    private async Task ResetConversationAsync()
    {
        CancelAnyCurrentResponse();
        messages.Clear();
        statefulMessageCount = 0;
        chatSuggestions?.Clear();
        await chatInput!.FocusAsync();
    }


    @* [Description("Searches for information using a phrase or keyword. Relies on documents already being loaded.")]
    private async Task<IEnumerable<string>> SearchAsync(
    [Description("The phrase to search for.")] string searchPhrase,
    [Description("If possible, specify the filename to search that file only. If not provided or empty, the search includes all files.")] string? filenameFilter = null)
    {
        await InvokeAsync(StateHasChanged);
        var url =
        $"/api/SemanticSearch/search?text={Uri.EscapeDataString(searchPhrase)}&documentIdFilter={Uri.EscapeDataString(filenameFilter
        ?? "")}&maxResults=5";
        var results = await httpClient!.GetFromJsonAsync<List<IngestedChunk>>(url);
        return results?.Select(result => $"<result filename=\"{result.DocumentId}\">{result.Text}</result>") ??
        Enumerable.Empty<string>();
    } *@

    public void Dispose()
    => currentResponseCancellation?.Cancel();
}